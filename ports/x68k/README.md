# MicroPython for X680x0

MicroPython のシャープ X680x0 向け移植です。

[MicroPython](https://micropython.org/) v1.20.0 をベースにしています。
* v1.19.1 からの差分は [こちら](https://github.com/micropython/micropython/releases/tag/v1.20.0) を参照してください。


## ビルド方法

ビルドにはPC環境のクロスツールチェイン [elf2x68k](https://github.com/yunkya2/elf2x68k) が必要です。
ツールチェインにパスが通って m68k-elf-gcc 等が実行できる状態で、以下の手順でビルドします。

```
$ cd ports/x68k
$ make
```

ビルドに成功すると実行ファイル `build/micropython.x` が出来るので、X680x0 の環境上にコピーしてください。

## 実行方法

* X680x0 環境上で micropython.x を実行します。

  ```
  micropython [ -h ] [ -i ] [ -O<level> ] [ -X <option> ] [ -m <module> | <script> ] [ <args> ]
  ```

### 起動オプション

* `-m <module>`
  * モジュール `<module>` を実行します。モジュールはカレントディレクトリまたは環境変数 `MICROPYPATH` で指定されるパスに存在している必要があります。
* `<script>`
  * ファイル `<script>` を実行します。スクリプトは有効な MicroPython ソースコードファイルである必要があります。

上記のオプションのいずれも指定されていない場合、MicroPython は対話型 REPL モードで実行されます。

* `<args>`
  * モジュール/スクリプトの後の追加の引数は `sys.argv` に渡されます。

### 一般オプション

* `-h`
  * コマンドラインの使用法を含むヘルプメッセージを出力して終了します。
* `-i`
  * 検査を有効にします。このフラグを設定すると、コマンド、モジュール、スクリプトが終了した後、MicroPython が対話型 REPL モードに入ります。これは、未処理の例外の後の状態をデバッグするのに役立ちます。環境変数 `MICROPYINSPECT` も参照してください。
* `-O` | `-O<level>` | `-OO`...
  * 最適化レベルを設定します。の `O` の後に数字を付けるか、 `O` を複数回繰り返すことによりレベルを示すことができます。たとえば `-O3` と `-OOO` は同じです。
* `-X <option>`
  * 追加の処理系固有のオプションを指定します。可能なオプションは次のとおりです:
  * `-X emit={bytecode,native,viper}` はデフォルトのコードエミッタを設定します。
  * `-X heapsize=<n>[w][K|M]` はガベージコレクターのヒープサイズを設定します。接尾辞 `w` はバイトではなくワードを意味します。 `K` は x1024、 `M` は x1024x1024 を意味します。

## 環境変数

* `MICROPYPATH`
  * MicroPython ライブラリの検索パスを設定します。検索パスは、ディレクトリのリストをコロンで区切ることで設定します。
* `MICROPYINSPECT`
  * この環境変数に空でない文字列が設定されていると、MicroPython はスクリプトの実行終了後に対話シェルモードに入ります。コマンドラインオプションの `-i` と同じ効果があります。
* `MICROPYHIST`
  * 対話シェルへの入力履歴を保存するファイル名を指定します。

## X680x0固有ライブラリ

MicroPython 自体の使い方は [公式ドキュメント](https://micropython-docs-ja.readthedocs.io/ja/v1.20ja/index.html) を参照してください。

X680x0版では、加えて以下のライブラリをサポートしています。

### `machine` --- ハードウェア関連の関数

X680x0版では以下のクラスのみをサポートしています。

#### クラス `Pin` -- I/O ピンの制御(を模したキーボードLEDの制御)

通常の MicroPython では `Pin` はMCUのI/O ピン (GPIO - 汎用入出力)の制御のために使用されますが、X680x0版ではすべて出力ピンとして、ピン#0～#6がキーボードの各LEDに対応します。
MicroPython向けLチカのコードをそのままX680x0版で動かすためだけに存在します。:-)

### `x68k` --- X680x0 固有ハードウェア関連の関数

* `x68k.crtmod(mode [,gon])`
  * 画面の表示モードを設定する IOCS CRTMOD を実行します。mode には設定する画面モードを指定します。
  * gon を `True` にすると、画面モード設定後にグラフィック画面をクリアして表示モードにします(IOCS G_CLR_ON の実行)。
* `x68k.vsync()`
  * CRTCの垂直帰線期間になるまで待ちます。
* `x68k.curon()`
* `x68k.curoff()`
  * カーソル表示をON/OFFします。
* `x68k.fontrom()`
  * フォントROM領域の `memoryview` オブジェクトを返します。読み出し専用です。
* `x68k.i.<IOCSコール名>`
  * IOCSコール番号を定数で定義しています。
    * 例: `x68k.i.B_PRINT` = 0x21
* `x68k.iocs(d0, d1, d2, d3, d4, d5, a1[w], a2[w], rd, ra)`
  * IOCSコールを実行します。`d0`～`d5`,`a1`,`a2` は呼び出しの際のCPUレジスタ値を指定します。`d0`以外は省略可能です。
    * 例: `x68k.iocs(x68k.i.B_KEYINP)`  # IOCS _B_KEYINPを実行します
  * CPUレジスタ引数には整数値を直接指定する他に、バッファオブジェクトを指定することも可能です。この場合の挙動はレジスタの種類によって異なります。
    * データレジスタの場合は、与えられたオブジェクトの先頭4バイトを整数値として使用します。
      * x68k.iocs()に渡されるPythonの引数は32bit符号付き整数として扱われるため、これに収まらない値(0x80000000のような)は直接引数として与えることができません。バッファオブジェクトを介して `d1=struct.pack('L',0x80000000))` のようにすることで渡せるようになります。
    * アドレスレジスタの場合は、与えられたオブジェクトの先頭アドレスが渡されます。
      * 与えられたバッファに書き込みを行うようなIOCSに対しては、名前を `a1w`, `a2w` にして`bytearray`のような書き換え可能なオブジェクトを与えます。
  * IOCS実行後のd0レジスタの値が関数の戻り値となります。他のレジスタの値が必要な場合は、`rd`, `ra`にそれぞれデータレジスタ、アドレスレジスタの個数を指定することでそれらのレジスタ値を並べたタプルを返します。
    * `rd=2`, `ra=1` を指定すると、関数の戻り値は `(d0,d1,d2,a1)` のタプルとなります。
* `x68k.d.<DOSコール名>`
  * DOSコール番号を定数で定義しています。
    * 例: `x68k.d.PRINT` = 0xff09
* `x68k.dos(callno [,arg])`
  * DOSコールを実行します。`callno`には呼び出すDOSコール番号を指定します。
    * 例: `x68k.dos(x68k.d.GETCHAR)`  # DOS _GETCHAR を実行します
  * DOSコール実行後のd0レジスタの値が関数の戻り値となります。
  * 追加の引数としてバッファオブジェクトを指定することができます。指定されたオブジェクトの内容がスタックに積み上げられてからDOSコールを実行します。オブジェクトのデータ配置、サイズは呼び出すDOSコールと正しく対応している必要があります。
    * 例:
      ```
      import x68k
      import struct
      import ctypes

      buf=bytearray(94)
      x68k.dos(x68k.d.GETDPB,struct.pack('hl',0,ctypes.addressof(buf)))
      ```
    * DOS _GETDPBは「1ワードのドライブ番号」「94バイトのバッファを指す1ロングワードのポインタ」をこの順にスタックに積んで呼び出す仕様なので、`struct.pack`のフォーマット文字列`'hl'` によってこのデータ配置を指定しています。
* `x68k.mpyaddr()`
  * MicroPython本体のメモリ上の開始アドレスを返します。デバッグ用です。

#### クラス `Super` -- スーパーバイザモード制御

* class `x68k.Super()`
  * Super オブジェクトを構築します。以下のように `with` ステートメントで使用することで、ブロック内をスーパーバイザモードで実行します。
  ```
  # ここまではユーザーモード

  with x68k.Super():
    # ここからスーパーバイザモード
    a = machine.mem32[0]    # スーパーバイザモードでアクセス

  # ここからはユーザーモード
  ```
* `x68k.issuper()`
  * スーパーバイザモードであれば `True` を、ユーザーモードであれば `False` を返します。
* `x68k.super([mode])`
  * スーパーバイザモードとユーザモードの間の切り替えを行います。
  * mode を省略または `True` であればスーパーバイザモードに、`False` であればユーザーモードに切り替えます。
  * 関数の戻り値として切り替え前のモードを返します。
  ```
  # ここまではユーザーモード

  s = x68k.super()

  # ここからスーパーバイザモード
  a = machine.mem32[0]    # スーパーバイザモードでアクセス

  x68k.super(s)

  # ここからはユーザーモード
  ```

#### クラス `GVRam` -- グラフィックスVRAM描画

* class `x68k.GVRam([page])`
  * GVRam オブジェクトを構築します。複数の描画ページを持つグラフィックスモードの場合は、pageに描画するページ番号を指定します。省略するとページ0を使用します。
  * 構築されるオブジェクトは指定した描画ページのグラフィックVRAMのフレームバッファとなります。`framebuf.FrameBuffer` オブジェクトのコンストラクタに与えることで、`framebuffer`クラスによる画面描画が可能です。

以下のメソッドによって描画を行います。

* `GVRam.palet(pal, col)` -- パレット設定
* `GVRam.home(x, y [,all])` -- 表示位置指定
* `GVRam.window(x0, y0, x1, y1)` -- 描画範囲設定
* `GVRam.wipe()` -- 画面クリア
* `GVRam.pset(x, y, c)` -- ポイント描画
* `GVRam.point(x, y)` -- ポイントゲット
* `GVRam.line(x0, y0, x1, y1, c [,style])` -- 直線描画
* `GVRam.box(x0, y0, x1, y1, c [,style])` -- ボックス描画
* `GVRam.fill(x0, y0, x1, y1, c)` -- 塗りつぶしボックス描画
* `GVRam.circle(x, y, r, c [,start, end, ratio])` -- 円描画
* `GVRam.paint(x, y, c [,buf])` -- シードフィル描画
* `GVRam.symbol(x, y, str, xmag, ymag, c [,ftype, angle])` -- 文字列描画
* `GVRam.get(x0, y0, x1, y1, buf)` -- 範囲内のデータ取得
* `GVRam.put(x0, y0, x1, y1, buf)` -- 範囲内へデータ書き込み
* `x68k.vpage(page)`
  * グラフィック画面の表示ページを設定します。`page`のビット0～ビット3が各ページ番号に対応します。
  ```
  import x68k
  x68k.crtmod(16,True)
  x68k.vpage(1)   # ページ0のみ表示
  g = x68k.GVRam(0)   # ページ0のオブジェクト構築
  g.line(0, 0, 767, 511, 11)
  g.fill(100, 100, 200, 200, 9)
  g.symbol(10, 300, 'MicroPython!', 2, 2, 7)
  ```

#### クラス `TVRam` -- テキストVRAM描画

* class `x68k.TVRam()`
  * TVRam オブジェクトを構築します。
  * 構築されるオブジェクトはテキストVRAMのフレームバッファとなります。`framebuf.FrameBuffer` オブジェクトのコンストラクタに与えることで、`framebuffer`クラスによる画面描画が可能です。

以下のメソッドによって描画を行います。

* `TVRam.palet(pal, col)` -- パレット設定
* `TVRam.palet2(pal, col)` -- パレット設定 (マウスプレーンを考慮しない)
* `TVRam.xline(plane, x, y, len [,style])` -- 横直線描画
* `TVRam.yline(plane, x, y, len [,style])` -- 縦直線描画
* `TVRam.line(plane, x, y, w, h [,style])` -- 直線描画
* `TVRam.box(plane, x, y, w, h [,style])` -- ボックス描画
* `TVRam.fill(plane, x, y, w, h [,style])` -- 塗りつぶしボックス描画
* `TVRam.rev(plane, x, y, w, h)` -- 矩形領域反転
* `TVRam.rascpy(src, dst, n, dir, plane)` -- ラスターコピー
* `TVRam.color(plane)` -- 描画対象プレーン設定
* `TVRam.get(x, y, buf)` -- 範囲内のデータ取得
* `TVRam.put(x, y, buf)` -- 範囲内へデータ書き込み
* `TVRam.clipput(x, y, buf, (x0, y0, x1, y1))` -- 範囲内へデータ書き込み(クリッピングあり)

#### クラス `Sprite` -- スプライト、BG描画

* class `x68k.Sprite()`
  * Sprite オブジェクトを構築します。

以下のメソッドによって描画を行います。

* `Sprite.init()` -- スプライト面の初期化
* `Sprite.disp([onoff])` -- スプライト面の表示ON/OFF (引数省略時は表示ON)
* `Sprite.clr([from][,to])` -- スプライトパターンのクリア
  * `from`, `to` にはクリアするパターンコードの先頭、末尾を指定します。
  * `from` だけを指定した場合はそのコードのパターンのみ、`from`, `to` とも省略した場合はすべてのパターンをクリアします。
* `Sprite.defcg(code, pat [,size])` -- スプライトパターンの定義
  * `pat` には定義するパターンをバッファオブジェクトで与えます。
    * `binascii.unhexlify()`を使うことで16進文字列を定義パターンに変換できます。
  * `size` に0を指定すると8×8ドットのパターン、1を指定または指定を省略すると16×16ドットのパターンを定義します。2を指定した場合は16×16ドットですがパターンの並びがIOCSコール_SP_DEFCGと同じになります(左上、左下、右上、右下の順)。
* `Sprite.set(plane[,x, y, code, prio [,vsync]])` -- スプライトレジスタの設定
  * パターンコード `code` のスプライトをプレーン `plane` の座標 `x`, `y` に優先度 `prio` で表示します。
  * `plane` 以外を省略すると、そのプレーンのスプライトを表示しません。
  * `vsync` でレジスタ設定前に垂直帰線期間になるまで待つかどうかを指定します。`True` を指定、またはパラメータを省略すると待ちます。
* `Sprite.palet(p, color [,pb][,vsync])` -- スプライトパレットの設定
  * パレットコード `p` のカラーコードを `color` に設定します。
  * `color` には設定したいカラーコードをそのまま指定する他、複数のカラーコードを並べたタプルを指定することができます。タプルを指定した場合は、`p` から連続したパレットコードにそれぞれカラーコードが設定されます。
  * `pb` で設定するパレットブロック番号を指定します。省略するとパレットブロック 1 となります。
  * `vsync` でパレット設定前に垂直帰線期間になるまで待つかどうかを指定します。`True` を指定、またはパラメータを省略すると待ちます。
* `Sprite.bgdisp(bg[,text][,disp])` -- BGコントロールレジスタの設定
  * `bg`で指定したBG面に表示するテキストページ、表示のON/OFFを設定します。
  * `text`, `disp` を省略すると、テキストページ 0 の表示 ON となります。
* `Sprite.bgfill(text, code)` -- BGテキストのフィル
  * `text`で指定したテキストページをパターンコード `code` で埋めます。
* `Sprite.bgput(text, x, y, code)` -- BGテキストの設定
  * `text`で指定したテキストページの座標 `x`, `y` にパターンコード `code` を設定します。
* `Sprite.bgget(text, y, y)` -- BGテキストの読み出し
  * `text`で指定したテキストページの座標 `x`, `y` のパターンコードを読み出して返します。
* `Sprite.bgscroll(bg, x, y [,vsync])` -- BG面のスクロール
  * `bg`で指定したBG面のスクロール位置を座標 `x`, `y` に設定します。
  * `vsync` でスクロール設定前に垂直帰線期間になるまで待つかどうかを指定します。`True` を指定、またはパラメータを省略すると待ちます。

#### クラス `IntVSync`, `IntRaster`, `IntTimerD`, `IntOpm` -- 割り込みハンドラ登録

* これらのクラスによって、Python言語で書かれた割り込みハンドラを登録することができます。割り込みハンドラには通常の関数と異なるさまざまな制約が存在します。詳細は[公式ドキュメント](https://micropython-docs-ja.readthedocs.io/ja/v1.20ja/reference/isr_rules.html)を参照してください。
  * 割り込みハンドラは後述のネイティブコードまたはバイパーコード、インラインアセンブラを使用するなどして、出来るだけ早く処理を完了させるようにしてください。
* class `x68k.IntVSync([callback, arg, mode, disp, cycle])`
  * IntVSync オブジェクトを構築します。このオブジェクトで垂直同期による割り込みハンドラを登録します。
  * `callback` には垂直同期の際に呼び出すコールバックを指定します。指定できるのは、関数名のような呼び出し可能(callable)なオブジェクトです。
  * `arg` にはコールバックを呼び出す際に渡す引数を指定します。
  * `mode` にはコールバックがどのように呼び出されるのかを示す呼び出しモードを指定します。
    * `mode` 指定を省略するか 0 を指定した場合、コールバックはCPUの割り込みハンドラから直接呼び出されます。割り込み要因発生後ただちに呼び出される一方で、実行中にオブジェクトのインスタンス作成等メモリ確保を伴う操作ができないなどの制約があります。
    * `mode` に 1 を指定した場合、コールバックは `micropython.schedule` 機能を用いてキューに入れられ、CPUの割り込みハンドラが終了してメインプログラムに復帰した後に実行されます。実行開始までの遅延がある一方で、メモリ確保における制約などはなく通常のPythonプログラムのような操作が可能です(LinuxなどのOSの割り込み処理における、ボトムハーフに相当する機能です)。
  * `disp` を省略または 0 を指定すると、コールバックは垂直帰線区間に入ると呼び出されます。1 を指定すると垂直表示区間に入ると呼び出されます。
  * `cycle` は垂直同期何回ごとにコールバックを呼び出すかを指定します。省略すると 1 を指定したことになり、毎垂直同期ごとにコールバックが呼ばれます。

  以下のように `with` ステートメントで使用することで、割り込みハンドラはブロック内でのみ有効となります。実行がブロックの外に出る際に割り込みハンドラの登録も削除されます。
  ```
  # ここまでは割り込みハンドラ登録なし

  with x68k.IntVSync(callback, ... ):
    # この中では垂直同期ごとにcallbackが呼ばれる

  # 割り込みハンドラ登録なし
  ```

  構築したオブジェクトには以下のようなメソッドを呼び出すこともできますが、割り込みハンドラを登録したままプログラムを終了させるとシステムクラッシュなどの致命的な問題が発生する場合があるため、できるだけ上記の `with` ステートメントを用いるようにしてください。
  * `IntVSync.init([callback, arg, mode, disp, cycle])`
    * `a = x68k.IntVSync()` のように引数なしで構築したオブジェクトに対して、後付けで各引数を設定します。
  * `IntVSync.deinit()`
    * 割り込みハンドラの登録を解除します。
  * `IntVSync.callback([callback])`
    * オブジェクトにコールバックのみを設定します。引数を省略すると割り込みハンドラの登録を解除します。

* class `x68k.IntRaster([callback, arg, mode, raster])`
  * IntRaster オブジェクトを構築します。このオブジェクトでCRTCのラスター走査割り込みハンドラを登録します。
  * 引数の意味は `x68k.IntVSync` と同様です。
  * `raster` には割り込みを発生させるラスター番号を指定します。
* class `x68k.IntTimerD([callback, arg, mode, unit, cycle])`
  * IntTimerD オブジェクトを構築します。このオブジェクトでMFP Timer-Dの割り込みハンドラを登録します。
  * 引数の意味は `x68k.IntVSync` と同様です。
  * `unit` には後述の割り込み周期の単位時間を指定します(1 = 1μs / 2 = 2.5μs / 3 = 4μs / 4 = 12.5μs / 5 = 16μs / 6 = 25μs / 7 = 50μs  )
  * `cycle` には割り込み周期を指定します(0を指定すると256として扱います)。 `unit` × `cycle` が実際の割り込み周期となります。
* class `x68k.IntOpm([callback, arg, mode])`
  * IntOpm オブジェクトを構築します。このオブジェクトでFM音源IC(OPM)の割り込みハンドラを登録します。割り込みを発生させるには更にOPMレジスタを操作する必要があります。
  * 引数の意味は `x68k.IntVSync` と同様です。

#### クラス `x68k.IntDisable` -- 割り込み制御

* class `x68k.IntDisable()`
  * IntDisable オブジェクトを構築します。以下のように `with` ステートメントで使用することで、ブロック内は割り込み禁止状態で実行されます。
  * `x68k.Super()` によってスーパーバイザモードになった状態で実行する必要があります。ユーザモードだった場合には何もしません。
  ```
  # ここまでは割り込み許可

  with x68k.IntDisable():
    # 割り込み禁止状態

  # ここからは割り込み許可
  ```

  以下の関数による割り込み禁止/許可もできますが、割り込み禁止状態のままプログラムを終了させるとキーボード入力が効かなくなるなどの致命的な問題が発生する場合があるため、できるだけ上記の `with` ステートメントを用いるようにしてください。
* `x68k.intDisable()`
  * 割り込み禁止状態にして、以前の SR レジスタの値を返します。
* `x68k.intEnable(oldsr)`
  * 渡された `oldsr` の値を SR レジスタに設定します。
  ```
  # ここまでは割り込み許可

  oldsr = x68k.intDisable()

  # 割り込み禁止状態

  x68k.intEnable(oldsr)

  # ここからは割り込み許可
  ```

## 日本語文字列の扱い

`str` クラスでの日本語文字列の扱いに対応しています。
オリジナルのMicroPythonは文字列を内部的にUTF-8で扱っていますが、X680x0の文字コードはシフトJISなので、文字列の内部処理に手を入れてシフトJISのまま扱うようになっています。

このため、Python文字列内のエスケープシーケンス '\uXXXX' はUnicodeではなくシフトJISのコード番号を指定します。

`str`オブジェクトと`bytes`/`bytearray`オブジェクトでは日本語文字列を代入したときの扱いが異なります。`str`オブジェクトは多バイト文字を文字単位で扱いますが、`bytes`/`bytearray`オブジェクトではバイトの並びとして扱います。

```
>>> a=str('日本語','')      # strオブジェクトを作成
>>> a
'\u93fa\u967b\u8cea'
>>> len(a)                  # 文字数は3文字
3
>>> print(a)
日本語

>>> b=bytes('日本語','')    # bytesオブジェクトを作成
>>> b
b'\x93\xfa\x96{\x8c\xea'
>>> len(6)                  # 6バイト
6
>>> print(b)
b'\x93\xfa\x96{\x8c\xea'
```

## インラインアセンブラ

MicroPythonのインラインアセンブラ機能をサポートしています。
`@micropython.asm_m68k` デコレータを付けた関数はインラインアセンブラ関数となります。

詳細は[こちらのドキュメント](README-inlineasm.md)を参照してください。

## ネイティブ/バイパーコードエミッター

MicroPythonのネイティブ/バイパーコードエミッター機能をサポートしています。

`@micropython.native` または `@micropython.viper` デコレータを付けた関数では通常のバイトコードの代わりにCPUの機械語コードが出力され、それをCPUが直接実行することで実行速度を高速化します。

詳細は公式ドキュメントの [ネイティブコードエミッター](https://micropython-docs-ja.readthedocs.io/ja/v1.20ja/reference/speed_python.html#the-native-code-emitter) および [バイパーコードエミッター](https://micropython-docs-ja.readthedocs.io/ja/v1.20ja/reference/speed_python.html#the-viper-code-emitter) を参照してください。

## `mpycross` プリコンパイラ

* MicroPython はキーボードやファイルから入力されたプログラムをバイトコードにコンパイルしてから実行するため、特に大きなプログラムでは実行開始までに時間がかかります。
* `mpycross.x` はバイトコードへのコンパイルを事前に行うことで、プログラムの実行開始までの時間を短縮することができます。通常のPythonモジュールの `.py`ファイルを元に、`.mpy`ファイルを生成します。
  * 例: `mpycross sample/sprite.py`
    * sprite.py と同じディレクトリに sprite.mpy を生成します。

## モジュールのimportに関しての注意点

* Pythonの `import` では.pyファイルを納めたディレクトリ名がモジュール名として扱われますが、Human68kのシステムディスクに `SYS` ディレクトリがあるため、このルートディレクトリで `import sys` を行うと組み込みの `sys` モジュールがimportされないという問題があります。
* 組み込みモジュールは外部モジュールより優先して扱われるのですが、MicroPythonの本来の組み込みモジュール名は"u"の付いた `usys` であり `sys` はその別名という扱いになっていて、別名の方は外部モジュールに優先しないためこのような現象が起きるようです。
* 組み込みモジュールのimportが上手くいかない場合、モジュール検索パス上に同名のディレクトリがないかを確認してみて下さい。本来のモジュール名を用いた `import usys` であれば、組み込みモジュールが優先されます。

## ライセンス

MicroPython 本体は MITライセンスで配布されています。
X680x0ハードウェア固有の実装部分についても、MicroPython 本体のライセンス条件に従います。