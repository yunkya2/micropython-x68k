## MicroPython for X680x0 のインラインアセンブラについて

一部のCPUアーキテクチャ向けMicroPythonでは、関数をアセンブリ言語で記述するインラインアセンブラに対応しています。
Arm Thumb2アーキテクチャ向けのインラインアセンブラについては、公式ドキュメントの [チュートリアル](https://micropython-docs-ja.readthedocs.io/ja/latest/pyboard/tutorial/assembler.html)、[Inline assembler for Thumb2 architectures](https://micropython-docs-ja.readthedocs.io/ja/latest/reference/asm_thumb2_index.html) で説明されています。

MicroPython for X680x0 でも同様に、関数を 68000 CPU(MPU)のアセンブリ言語で記述することができます。

(現在、68000命令のみをサポートしています。68010/020/030/040/060の命令は未サポートです)

## インラインアセンブラ関数の書き方

インラインアセンブラ関数には特殊な関数デコレータ `@micropython.asm_m68k` が付きます。基本的なインラインアセンブラ関数の例を以下に示します。

```
@micropython.asm_m68k
def asmtest(a,b):
    movel([8,fp],d0)
    addl([12,fp],d0)
```

インラインアセンブラ関数は、通常のC言語の関数と同じ呼び出し規約で呼び出されます。すなわち、
* 関数引数はスタックに積み上げられて渡されます
* 関数実行後のd0レジスタの値が関数の戻り値となります

この呼び出し規約をサポートするために、インラインアセンブラで記述される関数の前後には関数エピローグ、プロローグのコードが追加されます。上記の例の場合、実際に生成されるアセンブラコードは以下のようになります(モトローラ形式で記述)。

```
asmtest:
    link    a6,#0
    movem.l d2-d7/a2-a5,-(sp)
    move.l  8(a6),d0
    add.l   12(a6),d0
    movem.l (sp)+,d2-d7/a2-a5
    unlk    a6
    rts
```

これにより、この関数をPython言語から呼び出すと、与えられた2つの引数を加算した結果が返ります。

```
print(asmtest(1,2))
3
```

## インラインアセンブラ関数の注意

関数をインラインアセンブラで書く場合、以下のような注意点があります。
 
* 関数はC言語の呼び出し規約にしたがって呼び出されます(前述)
  * 引数はスタックに積み上げられ、フレームポインタ(a6レジスタ)からの相対位置でアクセスできます
  * 関数終了後のd0レジスタ値が関数の戻り値となります
  * d0-d7, a0-a5レジスタは関数内で自由に使用できます
* 関数はリロケータブルに書く必要があります
  * アセンブルはPythonソースコードが読み込まれてバイトコンパイルされる際に行われ、MicroPythonのバイトコードの中に命令コードが直接埋め込まれます。バイトコードを再読み込みする際、アセンブルの時と異なるアドレスに配置される可能性があります
* インラインアセンブラ関数内からPython言語側の変数などを直接参照することはできません
  * `1+2` のように、アセンブル時に値が確定する定数式は使用できます
  * `const`を用いて、`VALUE = const(1234)`のように定義された定数であれば関数内に書くことができます
* 関数引数は、それが整数であればそのまま渡され、バイトオブジェクトであればそのアドレスが渡されます
  * データを `bytearray()` 変数などにして渡すことで、Python言語との間でデータのやり取りが可能になります

インラインアセンブラ関数の中では、以下の疑似命令が利用可能です

* `label(LABEL)`
  * 関数内でラベルを定義することができます。ラベルはブランチ命令の飛び先やPC相対アドレッシングの参照先として利用できます
  * Python言語の文法に従うため、関数中でインデントを変えることができません。`label`命令も他の命令と同じインデントに置く必要があります
* `data(size, data0, data1, ...)`
  * アセンブラの出力コード中に定数データを埋め込みます。`size`には個々のデータサイズをバイト単位で指定します (1=byte, 2=word, 4=long word)
* `align(nBytes)`
  * コード出力アドレスが`nBytes`の倍数になるようにします

## インラインアセンブラ関数内での68000命令

インラインアセンブラ関数はMicroPython内のパーサーを使用するため、Python言語の文法に合った記述が求められます。このため、命令はAS.XやHAS.Xなどで用いられるモトローラ形式とも、GNUアセンブラで用いられるMIT形式とも異なる独自の形式で記述する必要があります。

### 命令コード

* 68000の命令コード(オペコード)とオペランドの間はスペース区切りでなく、オペランドを引数に取った関数呼び出しのように記述します。オペランドのソース、デスティネーション順はそのままです
  * 例: `exg d0,d1` → `exg(d0,d1)`
* 命令コードのサイズは、ドット(`.`)を使わず命令に続けて直接指定します
  * 例: `move.w d0,d1` → `movew(d0,d1)`
* 複数のサイズが指定できる命令で指定を省略すると、選択できるサイズのうち最大のものが使われます
  * 例: `move(d0,d1)` ... `movel(d0,d1)` / `move.l d0,d1` と同じです
  * (AS.XやHAS.Xなどでサイズ省略時にワード(w)が使われるのと挙動が異なるので注意してください)
* 68000命令のうち and と or はPython言語の予約語でもあるため、サイズを省略するとシンタックスエラーとなります。必ず `andw` や `orb` のようにサイズを指定してください

### オペランド

* レジスタ名 `d0`～`d7`、`a0`～`a7`、`sr`、`ccr`、`usp`、`pc` はそのまま使用できます
  * `fp`(フレームポインタ)は`a6`の、`sp`(スタックポインタ)は`a7`の別名として使えます
* イミディエイトアドレッシングを表す `#` は使用できません(Python言語のコメントになるため)。イミディエイト値は`#`を置かずに直接書きます
  * 例: `addi.w #0x1234,d0` → `addiw(0x1234,d0)`
* 間接アドレッシングを表す`(`～`)`は、代わりに`[`～`]`を使用します
  * 例: `move.w (a0),d0` → `movew([a0],d0)`
* 絶対ロング/ショートアドレッシングも`[`～`]`で囲みます
  * 例: `move.w 0xc00000,d0` → `movew([0xc00000],d0)`
* ポストインクリメント/プリデクリメントアドレッシングは、アドレスレジスタの後ろに`.inc`、`.dec`を追加します
  * 例: `move.w (a0+),d0` → `movew([a0.inc],d0)`
* ディスプレースメント付きやインデックス付きの間接アドレッシングでは、アドレスレジスタ、ディスプレースメント、インデックスレジスタの各要素を任意の順番で並べることができます。ディスプレースメント以外の要素は`[`～`]`の前にも置けます
  * 例: `move.w 0x12(a0,d0.w),d1` → `movew([0x12,a0,d0.w],d1)`
    * `[a0,d0.w,0x12]` や `a0[d0.w,0x12]` のようにも書けます
* `movem`命令で使用するレジスタリストは、`{`～`}` で囲って指定します。レジスタは`/`または`,`で区切る他、`-`で範囲指定することができます
  * 例: `movem.l (sp)+,d0-d7/a0-a6` → `moveml([sp.inc],{d0-d7,a0-a6})`

アドレッシングモードごとのオペランドの指定例をまとめると以下のようになります。

|アドレッシングモード                         | MicroPython  |モトローラ形式| MIT形式       |
|---------------------------------------------|--------------|--------------|---------------|
|データレジスタ直接                           | d0           | d0           | %d0           |
|アドレスレジスタ直接                         | a0           | a0           | %a0           |
|アドレスレジスタ間接                         | [a0]         | (a0)         | %a0@          |
|ポストインクリメント付きアドレスレジスタ間接 | [a0.inc]     | (a0)+        | %a0@+         |
|プリデクリメント付きアドレスレジスタ間接     | [a0.dec]     | -(a0)        | %a0@-         |
|ディスプレースメント付きアドレスレジスタ間接 | [d16,a0]     | d16(a0)      | %a0@(d16)     |
|インデックス付きアドレスレジスタ間接         | [d8,a0,d0.w] | d8(a0,d0.w)  | %a0@(d8,d0:w) |
|ディスプレースメント付きPC相対               | [d16,pc]     | d16(pc)      | %pc@(d16)     |
|インデックス付きPC相対                       | [d8,pc,d0.l] | d8(pc,d0.l)  | %pc@(d8,d0:l) |
|絶対ショート                                 | [xxxx.w]     | (xxxx).w     | xxxx:w        |
|絶対ロング                                   | [xxxx.l]     | (xxxx).l     | xxxx:l        |
|イミディエイト                               | xxxx         | #xxxx        | #xxxx         |
|レジスタリスト                               | {d0-d2/a0}   | d0-d2/a0     | %d0-%d2/%a0   |

